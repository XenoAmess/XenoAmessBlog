---
title: 2021/3/23的修行
date: 2021-3-24 00:11:24
tags: [ '修行' ]
my: XenoAmess
---

……迄今为止的两三个月，我都在尝试去做太阳，变得更加美好，想去温暖一下别人，之类的

但是，已经没有什么做太阳的必要了

这个迭代的我，需要让自己开心起来

将别人作为生命的意义果然太过愚蠢，且会招致痛苦

但是，那也太美好了……

你们人类拥有很多很美好的东西……美好到让人沉迷

但是最终也太过痛苦了吧，哈哈

嗯，有些事情尝试过就可以了

下次不会再付出全部心去爱别人，或者把别人的幸福凌驾于自己的幸福之上作为考量了

……嗯，我已经完全理解【信徒】的想法了

……如果说上个迭代，我们是被神明留在原地的【神官】或者【信徒】的话

那么 这个迭代 我想要做自己的【神】了。

### 1. 感受痛苦

### 2. 自我迭代

### 3. 修复apache-commons-vfs的bug一个，该bug会导致所有中文文件的FileObject.getPath引发Exception

#### 3.1 PR

https://github.com/apache/commons-vfs/pull/168

https://issues.apache.org/jira/browse/VFS-798

#### 3.2 表现

这个bug由我自己前几天探测到的。

主要表现是Linux系统中，对部分文件名或者路径中含有非英文字符的本地文件使用toPath()时，会生成非法的Path对象。

从而导致生成的Path对象使用toFile时抛出异常

#### 3.3 暴露UT

```java

package org.apache.commons.vfs2;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.vfs2.impl.StandardFileSystemManager;
import org.junit.Ignore;
import org.junit.Test;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;

public class FileObjectTest {

    StandardFileSystemManager fileSystemManager;

    {
        try {
            fileSystemManager = loadFileSystemManager();
        } catch (FileSystemException e) {
            e.printStackTrace();
        }
    }

    interface IOExceptionThrowingFunction<T, R> {
        R apply(T t) throws IOException;
    }

    /**
     * Expected contents of test files
     */
    public static final String TEST_FILE_CONTENT = "aaa";

    /**
     * Test file paths
     */
    public static final String[] TEST_FILE_PATHS = new String[]{
            "src/test/resources/test-data/好.txt",
            "src/test/resources/test-data/1 1.txt",
    };

    private static StandardFileSystemManager loadFileSystemManager() throws FileSystemException {
        StandardFileSystemManager fileSystemManager = new StandardFileSystemManager();
        fileSystemManager.setLogger(null);
        fileSystemManager.init();
        fileSystemManager.setBaseFile(new File(System.getProperty("user.dir")));
        return fileSystemManager;
    }

    @Test
    public void testToFile() throws IOException {
        testToFile(fileObject -> fileObject.getPath().toFile());
    }

    @Test
    public void testToFile2() throws IOException {
        testToFile(FileObjectTest::toFile2);
    }

    @Test
    public void testEqualsURI() throws FileSystemException {
        for (String testFilePath : TEST_FILE_PATHS) {
            FileObject fileObject = fileSystemManager.resolveFile(testFilePath);
            assertNotNull(fileObject);
            File file = new File(testFilePath).getAbsoluteFile();
            URI fileURI = file.getAbsoluteFile().toURI();
            URI fileObjectURI = fileObject.getURI();
            assertEquals(fileObjectURI, fileURI);
        }
    }

    @Test
    public void testEqualsPaths() throws FileSystemException {
        for (String testFilePath : TEST_FILE_PATHS) {
            FileObject fileObject = fileSystemManager.resolveFile(testFilePath);
            assertNotNull(fileObject);
            File file = new File(testFilePath).getAbsoluteFile();
            Path filePath = file.toPath();
            Path fileObjectPath = fileObject.getPath();
            assertEquals(filePath, fileObjectPath);
        }
    }

    private void testToFile(IOExceptionThrowingFunction<FileObject, File> function) throws IOException {
        for (String testFilePath : TEST_FILE_PATHS) {
            testToFile(function, testFilePath);
        }
    }

    private void testToFile(IOExceptionThrowingFunction<FileObject, File> function, String testFilePath) throws IOException {
        FileObject fileObject = fileSystemManager.resolveFile(testFilePath);
        assertNotNull(fileObject);
        try (InputStream inputStream = fileObject.getContent().getInputStream()) {
            assertEquals(TEST_FILE_CONTENT, IOUtils.toString(inputStream, StandardCharsets.UTF_8));
        }
        File file = function.apply(fileObject);
        assertNotNull(file);
        assertEquals(TEST_FILE_CONTENT, FileUtils.readFileToString(file, StandardCharsets.UTF_8));
    }

    private static File toFile2(FileObject fileObject) throws FileSystemException {
        if (fileObject == null || !"file".equals(fileObject.getURL().getProtocol())) {
            return null;
        }
        return new File(fileObject.getName().getPathDecoded());
    }

    /**
     * please only invoke this when you want to figure out what special characters
     * is not allowed in Path but allowed in File.
     */
    @Ignore
    @Test
    public void testFull() throws Exception {
        String folderString = "target/testTempOutput/FileObjectTest/";
        File folderFile = new File(folderString);
        folderFile.mkdirs();
        for (char c = 0; c < Character.MAX_VALUE; c++) {
            String fileString = folderFile.getAbsolutePath() + '/' + c + ".txt";
            File file = new File(fileString);
            try {
                file.createNewFile();
            } catch (Exception ignored) {
                continue;
            }
            try (FileWriter fileWriter = new FileWriter(file)) {
                fileWriter.write(TEST_FILE_CONTENT);
            }
            try {
                testToFile(fileObject -> fileObject.getPath().toFile(), file.getAbsolutePath());
            } catch (Exception e) {
                System.err.println("fails to use FileObject on : c = " + (int) c + " draws = " + c);
            }
        }
    }
}
```

#### 3.4 成因

##### 3.4.1 直接原因

是FileObject.toPath函数使用了toURI

```java
    /**
     * Returns a URI representing this file.
     *
     * @return the URI for the file.
     * @since 2.7.0
     */
    default URI getURI() {
        return URI.create(getName().getURI());
    }

    /**
     * Returns a Path representing this file.
     *
     * @return the Path for the file.
     * @since 2.7.0
     */
    default Path getPath() {
        return Paths.get(getURI());
    }
```

而commons-vfs和JDK对于URI的部分规则是不同的，这就导致了Paths使用JDK的规则去解析commons-vfs规则的URI，从而引发了这个问题

##### 3.4.2 本质原因

本质上，commons-vfs设计上和JDK使用共同的URL和URI两个类，而却不使用完全一致的规则，是这条bug的根本原因

已经向库维护者建议过，commons-vfs3的时候考虑使用自己的URL和URI类，和JDK解耦

然后需要的时候提供转换器

#### 3.5 修复方案

##### 3.5.1 彻底修复方案

重做vfs相关类，使用自己的URL和URI类，和JDK解耦

会造成[Binary Compatibility](https://stackoverflow.com/questions/14973380/what-is-binary-compatibility-in-java)

只能放在major version 3做了

（拜托……到时候都至少几年后了吧 哈哈 我还能见到吗？但愿能吧）

##### 3.5.1 应急修复方案

```java
    /**
     * Returns a Path representing this file.
     *
     * @return the Path for the file.
     * @since 2.7.0
     */
    default Path getPath() {
        URI uri = getURI();
        if ("file".equals(uri.getScheme())) {
            String rawPath = uri.getRawPath();
            if (!rawPath.startsWith("/")) {
                rawPath = "/" + rawPath;
            }
            uri = URI.create("file:" + rawPath);
        }
        return Paths.get(uri);
    }
```

有些朋友可能会认为，完全可以用

```java
    /**
     * Returns a Path representing this file.
     *
     * @return the Path for the file.
     * @since 2.7.0
     */
    default Path getPath() {
        URI uri = getURI();
        if ("file".equals(uri.getScheme())) {
            String rawPath = uri.getRawPath();
            return Paths.get(rawPath);
        }
        return Paths.get(uri);
    }
```

请这样认为的朋友自行去我的pr分支拉下来，跑一下被ignore的testFull测试

我是指，用我提供的和你这样简化的分别跑，然后对结果做一下compare，

就会知道，有几个比较特殊的字符只能我这么玩才能处理

### 4. 塑形课（1.5倍量）
